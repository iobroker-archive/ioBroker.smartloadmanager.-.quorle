'use strict';

const utils = require('@iobroker/adapter-core');

class ZeroFeedIn extends utils.Adapter {
    constructor(options) {
        super({
            ...options,
            name: 'smartloadmanager',
        });
        this.consumerList = [];
        this.feedInDatapoint = null;
        this.batteryControlModeDatapoint = null;
        this.percentTimer = null;
        this.batteryTimer = null;
        this.checkRunning = false;

        this.on('ready', this.onReady.bind(this));
        this.on('stateChange', this.onStateChange.bind(this));
        this.on('unload', this.onUnload.bind(this));
    }

    async onReady() {
        try {
            this.log.info(`=== Adapter gestartet - PID: ${process.pid} ===`);
            await this.sendNotification('Adapter smartloadmanager gestartet.', {
                title: 'Adapterstart',
                type: 'notify',
            });

            if (!this.config.FeedInDataPoint) {
                this.log.error('No FeedInDataPoint configured!');
                await this.sendNotification('Kein FeedInDataPoint konfiguriert!', {
                    title: 'Startfehler',
                    type: 'alert',
                });
                return;
            }
            this.feedInDatapoint = this.config.FeedInDataPoint;

            this.batteryControlModeDatapoint = this.config.batteryControlModeDatapoint || null;
            this.log.info(`Configured batteryControlModeDatapoint: ${this.batteryControlModeDatapoint}`);

            this.consumerList = Array.isArray(this.config.consumer)
                ? this.config.consumer.filter(
                      v => v && v.enabled && (v.ruletype === 'battery' || (v.datapoint && v.performance > 0)),
                  )
                : [];

            this.consumerList.forEach(v => (v.processingLockSwitch = false));

            this.log.info(`Loaded consumers: ${this.consumerList.map(v => v.name).join(', ')}`);

            await this.checkAndCreateConsumerObjects();
            await this.createConsumerStates();
            await this.initializeConsumerStatus();
            await this.subscribeStatesAsync('*');
            await this.subscribeForeignStatesAsync(this.feedInDatapoint);
            if (this.batteryControlModeDatapoint) {
                await this.subscribeForeignStatesAsync(this.batteryControlModeDatapoint);
            }

            await this.checkConsumers();
        } catch (error) {
            this.log.error(`Error in onReady: ${error.message}`);
            await this.sendNotification(`Fehler in onReady: ${error.message}`, {
                title: 'Adapterfehler',
                type: 'alert',
            });
        }
    }

    async checkAndCreateConsumerObjects() {
        for (const v of this.consumerList) {
            if (v.datapoint) {
                const obj = await this.getForeignObjectAsync(v.datapoint);
                if (!obj) {
                    this.log.warn(`Consumer datapoint ${v.datapoint} does not exist!`);
                    await this.sendNotification(
                        `Datenpunkt f√ºr Verbraucher "${v.name}" existiert nicht: ${v.datapoint}`,
                        { title: 'Fehlender Datenpunkt', type: 'alert' },
                    );
                }
            }
            if (v.numericDatapoint) {
                const objNum = await this.getForeignObjectAsync(v.numericDatapoint);
                if (!objNum) {
                    this.log.warn(`Consumer numericDatapoint ${v.numericDatapoint} does not exist!`);
                    await this.sendNotification(
                        `Numeric-Datenpunkt f√ºr Verbraucher "${v.name}" existiert nicht: ${v.numericDatapoint}`,
                        { title: 'Fehlender Datenpunkt', type: 'alert' },
                    );
                }
            }
        }
    }

    async createConsumerStates() {
        for (let i = 0; i < this.consumerList.length; i++) {
            const v = this.consumerList[i];
            const channelId = `consumer.${i}_${v.name.replace(/\s+/g, '_')}`;

            await this.setObjectNotExistsAsync(channelId, {
                type: 'channel',
                common: { name: v.name },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.controlMode`, {
                type: 'state',
                common: {
                    name: `${v.name} Control Mode`,
                    type: 'number',
                    role: 'level.mode',
                    read: true,
                    write: true,
                    states: { 0: 'Off', 1: 'Manual On', 2: 'Auto' },
                    def: 2,
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOnTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Switch On Time (HH:MM)`,
                    type: 'string',
                    role: 'value.time',
                    read: true,
                    write: true,
                    def: '',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOffTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Switch Off Time (HH:MM)`,
                    type: 'string',
                    role: 'value.time',
                    read: true,
                    write: true,
                    def: '',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.alwaysOffAtTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Ausschalten nur zur Ausschaltzeit`,
                    type: 'boolean',
                    role: 'switch',
                    read: true,
                    write: true,
                    def: v.alwaysOffAtTime || false,
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.performance`, {
                type: 'state',
                common: {
                    name: `${v.name} Gesamtleistung (Watt)`,
                    type: 'number',
                    role: 'value.power.consumption',
                    read: true,
                    write: false,
                    def: v.performance || 0,
                    unit: 'W',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOnPoint`, {
                type: 'state',
                common: {
                    name: `${v.name} Einschaltpunkt (Watt)`,
                    type: 'number',
                    role: 'value.power',
                    read: true,
                    write: false,
                    def: v.switchOnPoint || 0,
                    unit: 'W',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOffPoint`, {
                type: 'state',
                common: {
                    name: `${v.name} Abschaltpunkt (Watt)`,
                    type: 'number',
                    role: 'value.power',
                    read: true,
                    write: false,
                    def: v.switchOffPoint || 0,
                    unit: 'W',
                },
                native: {},
            });

            // Batterie-spezifische States
            if (v.ruletype === 'battery') {
                await this.setObjectNotExistsAsync(`${channelId}.batterySetpoint`, {
                    type: 'state',
                    common: {
                        name: `${v.name} Batterie Ladeleistungs-Datenpunkt`,
                        type: 'string',
                        role: 'value',
                        read: true,
                        write: true,
                        def: v.batterySetpoint || '',
                    },
                    native: {},
                });
            }

            // Initiale Werte setzen
            const finalOnTime = v.switchOnTime || '';
            const finalOffTime = v.switchOffTime || '';

            await this.setStateAsync(`${this.namespace}.${channelId}.switchOnTime`, { val: finalOnTime, ack: true });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOffTime`, { val: finalOffTime, ack: true });
            await this.setStateAsync(`${this.namespace}.${channelId}.alwaysOffAtTime`, {
                val: v.alwaysOffAtTime || false,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOffPoint`, {
                val: v.switchOffPoint || 0,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOnPoint`, {
                val: v.switchOnPoint || 0,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.performance`, {
                val: v.performance || 0,
                ack: true,
            });

            v.switchOnTime = finalOnTime;
            v.switchOffTime = finalOffTime;
        }
    }

    timeWithinWindow(onTime, offTime, name) {
        if (!onTime || !offTime) {
            return true;
        }

        const now = new Date();
        const currentMinutes = now.getHours() * 60 + now.getMinutes();
        const onMinutes = this.parseTimeToMinutes(onTime);
        const offMinutes = this.parseTimeToMinutes(offTime);

        const within = currentMinutes >= onMinutes && currentMinutes < offMinutes;

        if (name) {
            this.log.debug(
                `üïí ${name}: Zeitfenster ${onTime}‚Äì${offTime}, aktuell ${now.toTimeString().slice(0, 5)} (${currentMinutes} min) ‚Üí innerhalb? ${within}`,
            );
        }

        return within;
    }

    async onStateChange(id, state) {
        if (!state || state.ack) {
            return;
        }

        this.log.debug(`State changed: ${id} => ${state.val}`);

        // === controlMode √§ndern ===
        const match = id.match(/consumer\.(\d+)_.*?\.controlMode/);
        if (match) {
            const index = parseInt(match[1]);
            const mode = state.val;
            const v = this.consumerList[index];

            if (mode === 0) {
                await this.switchConsumerWithDelay(v, false);
            } else if (mode === 1) {
                await this.switchConsumerWithDelay(v, true);
            }

            // Notification f√ºr Binary-Verbraucher
            if (v.ruletype === 'binary' && this.config.notifyBinary) {
                await this.sendNotification(
                    `${v.name} wurde ${mode === 0 ? 'ausgeschaltet' : 'eingeschaltet'} (Manueller Modus)`,
                    { title: 'Verbraucher', type: 'notify' },
                );
            }
        }

        // === Zeitfenster √§ndern ===
        const timeMatch = id.match(/consumer\.(\d+)_.*?\.(switchOnTime|switchOffTime)/);
        if (timeMatch) {
            const index = parseInt(timeMatch[1]);
            const type = timeMatch[2];
            this.consumerList[index][type] = state.val || '';
            await this.checkConsumers();
        }

        // === FeedIn Wert ===
        if (id === this.feedInDatapoint) {
            await this.checkConsumers();

            // Prozent-Verbraucher
            if (this.percentTimer) {
                clearTimeout(this.percentTimer);
            }
            this.percentTimer = setTimeout(
                async () => {
                    for (const v of this.consumerList.filter(v => v.ruletype === 'percent')) {
                        await this.controlPercentConsumer(v);
                    }
                    this.percentTimer = null;
                },
                (this.config.delaySecondsProzent || 60) * 1000,
            );

            // Batterie-Verbraucher
            if (this.batteryTimer) {
                clearTimeout(this.batteryTimer);
            }
            this.batteryTimer = setTimeout(
                async () => {
                    if (!this.feedInDatapoint) {
                        return;
                    }
                    const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);
                    let feedIn = Number(feedInState?.val) || 0;
                    if (this.config.feedinNegativ) {
                        feedIn = -feedIn;
                    }

                    for (const v of this.consumerList.filter(v => v.ruletype === 'battery')) {
                        await this.controlBattery(v, feedIn);
                    }
                    this.batteryTimer = null;
                },
                (this.config.batteryDelaySeconds || 60) * 1000,
            );
        }
    }

    async checkConsumers() {
        if (this.checkRunning) {
            return;
        }
        this.checkRunning = true;

        try {
            if (!this.feedInDatapoint) {
                this.log.warn('‚ùó Kein FeedIn-Datenpunkt gesetzt ‚Äì checkConsumers() wird √ºbersprungen.');
                this.checkRunning = false;
                return;
            }

            const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);
            let feedIn = Number(feedInState?.val) || 0;
            if (this.config.feedinNegativ) {
                feedIn = -feedIn;
            }

            const baseload = this.config.baseload || 0;
            const gridUsage = feedIn <= baseload;

            this.log.debug(`üìä FeedIn: ${feedIn} W, Baseload: ${baseload} W, GridUsage: ${gridUsage}`);

            // ----------------------------------
            // Einschalten binary (aufsteigend nach Prio)
            // ----------------------------------
            const sortedOn = [...this.consumerList]
                .filter(v => v.ruletype === 'binary')
                .sort((a, b) => (a.priority || 1) - (b.priority || 1));

            this.log.debug(`üîç Einschalt-Pr√ºfung f√ºr ${sortedOn.length} binary-Verbraucher.`);

            for (const v of sortedOn) {
                const idx = this.consumerList.indexOf(v);
                const id = `${this.namespace}.consumer.${idx}_${v.name.replace(/\s+/g, '_')}`;
                const mode = await this.getStateAsync(`${id}.controlMode`);

                this.log.debug(`‚û°Ô∏è Pr√ºfe "${v.name}" (Prio ${v.priority}, ${v.performance} W)`);

                if (!mode || mode.val !== 2) {
                    this.log.debug(`‚è≠Ô∏è Manueller Modus aktiv, √úberspringe.`);
                    continue;
                }

                const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime, v.name);

                let isOn = false;
                if (v.datapoint) {
                    const dpState = await this.getForeignStateAsync(v.datapoint);
                    if (dpState?.val === true) {
                        isOn = true;
                    }
                }
                if (v.numericDatapoint) {
                    const numState = await this.getForeignStateAsync(v.numericDatapoint);
                    const numVal = Number(numState?.val) || 0;
                    if (numVal === 1) {
                        isOn = true;
                    }
                    this.log.debug(`üî¢ NumericDatapoint f√ºr "${v.name}": ${v.numericDatapoint} = ${numVal}`);
                }

                this.log.debug(`üí° "${v.name}" Status: isOn=${isOn}`);

                if (withinWindow) {
                    if (!gridUsage && v.performance <= feedIn - baseload && !isOn) {
                        this.log.debug(
                            `‚úÖ Einschalten m√∂glich: √úberschuss ${feedIn - baseload} W, innerhalb Zeitfenster (onDelay ${v.switchOnDelay || 0}s).`,
                        );
                        await this.switchConsumerWithDelay(v, true, v.switchOnDelay || 0);

                        feedIn -= v.performance;
                        this.log.debug(`üîÑ Verbleibender √úberschuss nach Zuschaltung: ${feedIn - baseload} W`);
                    } else if (gridUsage && !isOn) {
                        this.log.debug(`üö´ Nicht eingeschaltet: Netzbezug aktiv.`);
                    } else if (!isOn) {
                        this.log.debug(
                            `‚ö†Ô∏è Nicht eingeschaltet: √úberschuss zu gering (${feedIn - baseload} W < ${v.performance} W).`,
                        );
                    } else {
                        this.log.debug(`‚ÑπÔ∏è "${v.name}" ist bereits eingeschaltet ‚Äì keine Aktion n√∂tig.`);
                    }
                }
            }

            // ----------------------------------
            // Ausschalten binary (absteigend nach Prio)
            // ----------------------------------
            const sortedOff = [...this.consumerList]
                .filter(v => v.ruletype === 'binary')
                .sort((a, b) => (b.priority || 1) - (a.priority || 1));

            this.log.debug(`üîç Ausschalt-Pr√ºfung f√ºr ${sortedOff.length} binary-Verbraucher.`);

            for (const v of sortedOff) {
                const idx = this.consumerList.indexOf(v);
                const id = `${this.namespace}.consumer.${idx}_${v.name.replace(/\s+/g, '_')}`;
                const mode = await this.getStateAsync(`${id}.controlMode`);
                if (!mode || mode.val !== 2) {
                    continue;
                }

                const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime, v.name);

                let isOn = false;
                if (v.datapoint) {
                    const dpState = await this.getForeignStateAsync(v.datapoint);
                    if (dpState?.val === true) {
                        isOn = true;
                    }
                }
                if (v.numericDatapoint) {
                    const numState = await this.getForeignStateAsync(v.numericDatapoint);
                    const numVal = Number(numState?.val) || 0;
                    if (numVal === 1) {
                        isOn = true;
                    }
                }

                // Ausschalten nur, wenn aktuell an
                if (!isOn) {
                    continue;
                }

                if (v.alwaysOffAtTime && !withinWindow) {
                    this.log.debug(
                        `‚è≥ AlwaysOff aktiv: "${v.name}" - Zeitfenster vorbei, offDelay ${v.switchOffDelay || 0}s.`,
                    );
                    await this.switchConsumerWithDelay(v, false, v.switchOffDelay || 0);
                } else if (!v.alwaysOffAtTime && (!withinWindow || gridUsage)) {
                    this.log.debug(`‚è≥ Ausschalten: "${v.name}" - offDelay ${v.switchOffDelay || 0}s.`);
                    await this.switchConsumerWithDelay(v, false, v.switchOffDelay || 0);
                }
            }

            // ----------------------------------
            // Batterie-Verbraucher
            // ----------------------------------
            const batteryConsumers = this.consumerList.filter(c => c.ruletype === 'battery');
            for (const v of batteryConsumers) {
                await this.controlBattery(v, feedIn);
            }

            // --- Timer-Status anzeigen ---
            const runningTimers = this.consumerList
                .filter(c => c.timer && c.timerEnd)
                .map(c => {
                    const remaining = Math.max(0, Math.round((c.timerEnd - Date.now()) / 1000));
                    return `${c.name}: noch ${remaining}s`;
                });

            if (runningTimers.length > 0) {
                this.log.debug(`üìã Aktive Timer ‚Üí ${runningTimers.join(' | ')}`);
            } else {
                this.log.debug('üìã Keine aktiven Timer.');
            }
        } catch (err) {
            this.log.error(`Error in checkConsumers: ${err.message}`);
            await this.sendNotification(`Fehler in checkConsumers: ${err.message}`, {
                title: 'Laufzeitfehler',
                type: 'alert',
            });
        }

        this.checkRunning = false;
    }

    async controlPercentConsumer(v) {
        try {
            const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime);
            if (!withinWindow) {
                this.log.debug(`[Percent] ${v.name} au√üerhalb Zeitfenster ‚Äì auf 0% setzen`);
                await this.setForeignStateAsync(v.datapoint, 0);
                return;
            }

            if (!this.feedInDatapoint) {
                this.log.error('‚ùå feedInDatapoint ist nicht gesetzt!');
                await this.sendNotification('feedInDatapoint ist nicht gesetzt!', {
                    title: 'Prozentregelung',
                    type: 'alert',
                });
                return;
            }
            const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);
            const feedInValue = Number(feedInState?.val) || 0;
            let surplus = this.config.feedinNegativ
                ? feedInValue < 0
                    ? -feedInValue
                    : 0
                : feedInValue > 0
                  ? feedInValue
                  : 0;
            surplus -= this.config.baseload || 0;
            if (surplus < 0) {
                surplus = 0;
            }

            const maxPerformance = v.maxPerformance || v.performance || 1000;
            let newPercent = Math.round((surplus / maxPerformance) * 100);
            newPercent = Math.min(100, Math.max(newPercent, v.minPercentStart || 0));

            const state = await this.getForeignStateAsync(v.datapoint);
            const currentPercent = Number(state?.val) || 0;

            if (newPercent !== currentPercent) {
                await this.setForeignStateAsync(v.datapoint, newPercent);
                this.log.info(`üîÅ ${v.name} wurde auf ${newPercent}% geregelt`);
                if (this.config.notifyPercent) {
                    await this.sendNotification(`${v.name} wurde auf ${newPercent}% geregelt`, {
                        title: 'Prozentregelung',
                        type: 'notify',
                    });
                }
            } else {
                this.log.debug(`[Percent] ${v.name} bleibt bei ${currentPercent}%`);
            }
        } catch (error) {
            this.log.error(`‚ùå Fehler in controlPercentConsumer: ${error.message}`);
            await this.sendNotification(`Fehler in controlPercentConsumer: ${error.message}`, {
                title: 'Prozentregelung',
                type: 'alert',
            });
        }
    }

    async controlBattery(v, feedIn) {
        try {
            this.log.debug(`[Battery] Pr√ºfung f√ºr ${v.name}`);
            const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime);
            if (!withinWindow) {
                this.log.debug(`[Battery] ${v.name} au√üerhalb Zeitfenster ‚Äì auf 0`);
                if (v.batterySetpoint) {
                    await this.setForeignStateAsync(v.batterySetpoint, { val: 0, ack: true });
                }
                if (v.batteryControlModeDatapoint) {
                    await this.setForeignStateAsync(v.batteryControlModeDatapoint, { val: 0, ack: true });
                }
                return;
            }

            if (!v.batterySetpoint) {
                this.log.warn(`[Battery] ${v.name} hat keinen batterySetpoint`);
                await this.sendNotification(`Batterie "${v.name}" hat keinen batterySetpoint konfiguriert!`, {
                    title: 'Fehlender Datenpunkt',
                    type: 'alert',
                });
                if (v.batteryControlModeDatapoint) {
                    await this.setForeignStateAsync(v.batteryControlModeDatapoint, { val: 0, ack: true });
                }
                return;
            }

            let soc = null;
            let targetSoc = null;
            if (v.batterySOC && v.batteryTargetSOC) {
                const socState = await this.getForeignStateAsync(v.batterySOC);
                const targetSocState = await this.getForeignStateAsync(v.batteryTargetSOC);
                soc = Number(socState?.val);
                targetSoc = Number(targetSocState?.val);
                if (isNaN(soc) || isNaN(targetSoc)) {
                    this.log.warn(`[Battery] ${v.name}: Ung√ºltiger SOC oder targetSOC`);
                    soc = null;
                    targetSoc = null;
                }
            }

            const surplus = (this.config.feedinNegativ ? -feedIn : feedIn) - (this.config.baseload || 0);
            let powerToSet = 0;
            let modeToSet = 0;

            if (surplus <= 0) {
                powerToSet = 0;
                modeToSet = 0;
            } else if (soc !== null && targetSoc !== null && soc >= targetSoc) {
                powerToSet = 0;
                modeToSet = 1;
            } else {
                powerToSet = Math.min(surplus, v.performance || 1000);
                modeToSet = 2;
            }

            const oldPower = Number((await this.getForeignStateAsync(v.batterySetpoint))?.val) || 0;
            const oldMode = this.batteryControlModeDatapoint
                ? Number((await this.getForeignStateAsync(this.batteryControlModeDatapoint))?.val) || 0
                : -1;

            if (powerToSet !== oldPower) {
                await this.setForeignStateAsync(v.batterySetpoint, { val: powerToSet, ack: true });
                this.log.info(`üîÅ Batterie ${v.name}: Ladeleistung auf ${powerToSet}W gesetzt`);
                if (this.config.notifyBattery) {
                    await this.sendNotification(`Batterie ${v.name}: Ladeleistung auf ${powerToSet}W gesetzt`, {
                        title: 'Batterie',
                        type: 'notify',
                    });
                }
            }

            if (this.batteryControlModeDatapoint && modeToSet !== oldMode) {
                await this.setForeignStateAsync(this.batteryControlModeDatapoint, { val: modeToSet, ack: true });
                this.log.debug(`[Battery] ${v.name} Modus ge√§ndert: ${oldMode} ‚Üí ${modeToSet}`);
                if (this.config.notifyBattery) {
                    await this.sendNotification(`Batterie ${v.name}: Modus ge√§ndert auf ${modeToSet}`, {
                        title: 'Batterie',
                        type: 'notify',
                    });
                }
            }
        } catch (error) {
            this.log.error(`[Battery] Fehler f√ºr ${v.name}: ${error.message}`);
            await this.sendNotification(`Batterie-Fehler f√ºr ${v.name}: ${error.message}`, {
                title: 'Batterie',
                type: 'alert',
            });
        }
    }

    /**
     * Zentrale Schaltfunktion: setzt sowohl booleanen Schalter-DP als auch optionalen numerischen DP (0/1)
     *
     * @param consumer - Der Verbraucher, der geschaltet werden soll
     * @param turnOn - true zum Einschalten, false zum Ausschalten
     */
    async doSwitchConsumer(consumer, turnOn) {
        const targetState = !!turnOn;

        // Prim√§rer boolean-DP
        if (consumer.datapoint) {
            await this.setForeignStateAsync(consumer.datapoint, { val: targetState, ack: true });
        }

        // Optionaler numerischer DP
        if (consumer.numericDatapoint) {
            await this.setForeignStateAsync(consumer.numericDatapoint, { val: targetState ? 1 : 0, ack: true });
            this.log.debug(`üî¢ NumericDatapoint f√ºr "${consumer.name}" gesetzt auf ${targetState ? 1 : 0}`);
        }
    }

    async switchConsumerWithDelay(consumer, turnOn, delaySeconds) {
        const delay =
            delaySeconds !== undefined
                ? delaySeconds
                : turnOn
                  ? consumer.switchOnDelay || 0
                  : consumer.switchOffDelay || 0;

        this.log.debug(
            `‚è≥ Verz√∂gerung ${delay}s f√ºr ${turnOn ? 'Einschalten' : 'Ausschalten'} von "${consumer.name}".`,
        );

        const doSwitch = async () => {
            this.log.info(
                `üîÄ Schalte "${consumer.name}" ${turnOn ? 'EIN' : 'AUS'}${delay > 0 ? ' nach Delay' : ' sofort'}.`,
            );
            await this.doSwitchConsumer(consumer, turnOn);

            if (consumer.ruletype === 'binary' && this.config.notifyBinary) {
                await this.sendNotification(`${consumer.name} wurde ${turnOn ? 'eingeschaltet' : 'ausgeschaltet'}`, {
                    title: 'Verbraucher',
                    type: 'notify',
                });
            }
        };

        if (consumer.timer) {
            clearTimeout(consumer.timer);
            consumer.timer = null;
            consumer.timerEnd = null;
        }

        if (delay > 0) {
            consumer.timerEnd = Date.now() + delay * 1000;
            consumer.timer = setTimeout(async () => {
                await doSwitch();
                consumer.timer = null;
                consumer.timerEnd = null;
            }, delay * 1000);
            this.log.debug(`üìå Timer f√ºr "${consumer.name}" gestartet: ${delay}s bis ${turnOn ? 'EIN' : 'AUS'}`);
        } else {
            await doSwitch();
        }
    }

    /**
     * Zentrale, einheitliche Notification-Funktion
     *
     * @param {string} message - Die Nachricht
     * @param {object} options - Optionen
     * @param {string} [options.title] - Der Titel
     * @param {string} [options.type] - Der Typ ('notify'|'alert')
     */
    async sendNotification(message, options) {
        if (!options) {
            options = {};
        }
        const title = options.title || 'SmartLoadManager';
        const type = options.type || 'notify';

        try {
            await this.sendToAsync('notification-manager.0', 'registerUserNotification', {
                category: 'smartloadmanager',
                message: message,
                title: title,
            });
            this.log.debug(`üì® Notification gesendet: ${message}`);
        } catch (e) {
            this.log.debug(`Notification-Manager nicht verf√ºgbar: ${e.message}`);
            if (type === 'alert') {
                this.log.error(`${title}: ${message}`);
            } else {
                this.log.info(`${title}: ${message}`);
            }
        }
    }

    async initializeConsumerStatus() {
        // Initiale Status-Updates
        for (const v of this.consumerList) {
            const channelId = `consumer.${this.consumerList.indexOf(v)}_${v.name.replace(/\s+/g, '_')}`;
            const modeState = await this.getStateAsync(`${this.namespace}.${channelId}.controlMode`);
            if (!modeState) {
                await this.setStateAsync(`${this.namespace}.${channelId}.controlMode`, { val: 2, ack: true });
            }
        }
    }

    /*
    // Testfunktion
    async testBatteryControlModeWrite() {
        this.log.info(`Teste Schreibzugriff auf batteryControlModeDatapoint: ${this.batteryControlModeDatapoint}`);

        if (!this.batteryControlModeDatapoint) {
            this.log.error("batteryControlModeDatapoint nicht konfiguriert");
            return;
        }

        const obj = await this.getForeignObjectAsync(this.batteryControlModeDatapoint);
        if (!obj) {
            this.log.error(`batteryControlModeDatapoint ${this.batteryControlModeDatapoint} existiert nicht!`);
            return;
        }

        if (!obj.common?.write) {
            this.log.warn(`batteryControlModeDatapoint ist nicht schreibbar!`);
            return;
        }

        const valBefore = await this.getForeignStateAsync(this.batteryControlModeDatapoint);
        this.log.info(`Vor Schreibversuch aktueller Wert: ${valBefore?.val}`);

        try {
            await this.setForeignStateAsync(this.batteryControlModeDatapoint, { val: 1, ack: true });
            this.log.info(`Schreibversuch durchgef√ºhrt`);

            const valAfter = await this.getForeignStateAsync(this.batteryControlModeDatapoint);
            this.log.info(`Nach Schreibversuch aktueller Wert: ${valAfter?.val}`);
        } catch (e) {
            this.log.error(`Fehler beim Schreiben: ${e.message}`);
        }
    }
    */

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    parseTimeToMinutes(timeStr) {
        if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
            return 0;
        }
        const [h, m] = timeStr.split(':').map(Number);
        if (isNaN(h) || isNaN(m)) {
            return 0;
        }
        return h * 60 + m;
    }

    async onUnload(callback) {
        try {
            if (this.percentTimer) {
                clearTimeout(this.percentTimer);
            }
            if (this.batteryTimer) {
                clearTimeout(this.batteryTimer);
            }
            for (const v of this.consumerList) {
                if (v.timer) {
                    clearTimeout(v.timer);
                    v.timer = null;
                }
            }
            callback();
        } catch {
            callback();
        }
    }
}

if (require.main !== module) {
    module.exports = options => new ZeroFeedIn(options);
} else {
    new ZeroFeedIn();
}
