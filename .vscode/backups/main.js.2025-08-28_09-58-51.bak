'use strict';

const utils = require('@iobroker/adapter-core');

class ZeroFeedIn extends utils.Adapter {
    constructor(options) {
        super({
            ...options,
            name: 'smartloadmanager',
        });
        this.consumerList = [];
        this.feedInDatapoint = null;
        this.batteryControlModeDatapoint = null;
        this.percentTimer = null;
        this.batteryTimer = null;
        this.checkRunning = false;

        this.on('ready', this.onReady.bind(this));
        this.on('stateChange', this.onStateChange.bind(this));
        this.on('unload', this.onUnload.bind(this));
    }

    async onReady() {
        try {
            this.log.info(`=== Adapter started - PID: ${process.pid} ===`);

            if (!this.config.FeedInDataPoint) {
                this.log.error('No FeedInDataPoint configured!');
                // zus√§tzlich als alert melden
                await this.sendNotification('smartloadmanager', 'alarm', '‚ùó Kein FeedInDataPoint konfiguriert!');
                return;
            }
            this.feedInDatapoint = this.config.FeedInDataPoint;

            this.batteryControlModeDatapoint = this.config.batteryControlModeDatapoint || null;
            this.log.info(`Configured batteryControlModeDatapoint: ${this.batteryControlModeDatapoint}`);

            this.consumerList = Array.isArray(this.config.consumer)
                ? this.config.consumer.filter(
                      v =>
                          v &&
                          v.enabled &&
                          (v.ruletype === 'battery' || ((v.datapoint || v.numericDatapoint) && v.performance > 0)),
                  )
                : [];

            this.consumerList.forEach(v => (v.processingLockSwitch = false));

            this.log.info(`Loaded consumers: ${this.consumerList.map(v => v.name).join(', ')}`);

            await this.checkAndCreateConsumerObjects();
            await this.createConsumerStates();
            await this.initializeConsumerStatus();
            await this.subscribeStatesAsync('*');
            await this.subscribeForeignStatesAsync(this.feedInDatapoint);
            if (this.batteryControlModeDatapoint) {
                await this.subscribeForeignStatesAsync(this.batteryControlModeDatapoint);
            }

            await this.checkConsumers();

            // Info beim erfolgreichen Start
            if (!this.adapterStartedNotified) {
                await this.sendNotification(
                    'smartloadmanager',
                    'info',
                    '‚ÑπÔ∏è SmartLoadManager Adapter erfolgreich gestartet.',
                );
                this.adapterStartedNotified = true;
            }
        } catch (error) {
            this.log.error(`Error in onReady: ${error.message}`);
            // Fehler zus√§tzlich als alert melden
            await this.sendNotification('smartloadmanager', 'alert', `‚ùå Fehler in onReady: ${error.message}`);
        }
    }

    async checkAndCreateConsumerObjects() {
        for (const v of this.consumerList) {
            if (v.datapoint) {
                const obj = await this.getForeignObjectAsync(v.datapoint);
                if (!obj) {
                    this.log.warn(`Consumer datapoint ${v.datapoint} does not exist!`);
                }
            }
            if (v.numericDatapoint) {
                const objNum = await this.getForeignObjectAsync(v.numericDatapoint);
                if (!objNum) {
                    this.log.warn(`Consumer numericDatapoint ${v.numericDatapoint} does not exist!`);
                }
            }
        }
    }

    async createConsumerStates() {
        for (let i = 0; i < this.consumerList.length; i++) {
            const v = this.consumerList[i];
            const channelId = `consumer.${i}_${v.name.replace(/\s+/g, '_')}`;

            await this.setObjectNotExistsAsync(channelId, {
                type: 'channel',
                common: { name: v.name },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.controlMode`, {
                type: 'state',
                common: {
                    name: `${v.name} Control Mode`,
                    type: 'number',
                    role: 'level.mode',
                    read: true,
                    write: true,
                    states: { 0: 'Off', 1: 'Manual On', 2: 'Auto' },
                    def: 2,
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOnTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Switch On Time (HH:MM)`,
                    type: 'string',
                    role: 'value.time',
                    read: true,
                    write: true,
                    def: '',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOffTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Switch Off Time (HH:MM)`,
                    type: 'string',
                    role: 'value.time',
                    read: true,
                    write: true,
                    def: '',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.alwaysOffAtTime`, {
                type: 'state',
                common: {
                    name: `${v.name} Ausschalten nur zur Ausschaltzeit`,
                    type: 'boolean',
                    role: 'switch',
                    read: true,
                    write: true,
                    def: v.alwaysOffAtTime || false,
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.performance`, {
                type: 'state',
                common: {
                    name: `${v.name} Gesamtleistung (Watt)`,
                    type: 'number',
                    role: 'value.power.consumption',
                    read: true,
                    write: false,
                    def: v.performance || 0,
                    unit: 'W',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOnPoint`, {
                type: 'state',
                common: {
                    name: `${v.name} Einschaltpunkt (Watt)`,
                    type: 'number',
                    role: 'value.power',
                    read: true,
                    write: false,
                    def: v.switchOnPoint || 0,
                    unit: 'W',
                },
                native: {},
            });

            await this.setObjectNotExistsAsync(`${channelId}.switchOffPoint`, {
                type: 'state',
                common: {
                    name: `${v.name} Abschaltpunkt (Watt)`,
                    type: 'number',
                    role: 'value.power',
                    read: true,
                    write: false,
                    def: v.switchOffPoint || 0,
                    unit: 'W',
                },
                native: {},
            });

            // Batterie-spezifische States
            if (v.ruletype === 'battery') {
                await this.setObjectNotExistsAsync(`${channelId}.batterySetpoint`, {
                    type: 'state',
                    common: {
                        name: `${v.name} Batterie Ladeleistungs-Datenpunkt`,
                        type: 'string',
                        role: 'value',
                        read: true,
                        write: true,
                        def: v.batterySetpoint || '',
                    },
                    native: {},
                });
            }

            // Initiale Werte setzen
            const finalOnTime = v.switchOnTime || '';
            const finalOffTime = v.switchOffTime || '';

            await this.setStateAsync(`${this.namespace}.${channelId}.switchOnTime`, { val: finalOnTime, ack: true });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOffTime`, { val: finalOffTime, ack: true });
            await this.setStateAsync(`${this.namespace}.${channelId}.alwaysOffAtTime`, {
                val: v.alwaysOffAtTime || false,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOffPoint`, {
                val: v.switchOffPoint || 0,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.switchOnPoint`, {
                val: v.switchOnPoint || 0,
                ack: true,
            });
            await this.setStateAsync(`${this.namespace}.${channelId}.performance`, {
                val: v.performance || 0,
                ack: true,
            });

            v.switchOnTime = finalOnTime;
            v.switchOffTime = finalOffTime;
        }
    }

    timeWithinWindow(onTime, offTime, name) {
        if (!onTime || !offTime) {
            return true;
        }

        const now = new Date();
        const currentMinutes = now.getHours() * 60 + now.getMinutes();
        const onMinutes = this.parseTimeToMinutes(onTime);
        const offMinutes = this.parseTimeToMinutes(offTime);

        const within = currentMinutes >= onMinutes && currentMinutes < offMinutes;

        if (name) {
            this.log.debug(
                `üïí ${name}: Zeitfenster ${onTime}‚Äì${offTime}, aktuell ${now.toTimeString().slice(0, 5)} (${currentMinutes} min) ‚Üí innerhalb? ${within}`,
            );
        }

        return within;
    }

    async onStateChange(id, state) {
        if (state && !state.ack) {
            this.log.debug(`State changed: ${id} => ${state.val}`);

            const match = id.match(/consumer\.(\d+)_.*?\.controlMode/);
            if (match) {
                const index = parseInt(match[1]);
                const mode = state.val;
                const v = this.consumerList[index];

                if (mode === 0) {
                    await this.switchConsumerWithDelay(v, false);
                } else if (mode === 1) {
                    await this.switchConsumerWithDelay(v, true);
                }
            }

            const timeMatch = id.match(/consumer\.(\d+)_.*?\.(switchOnTime|switchOffTime)/);
            if (timeMatch) {
                const index = parseInt(timeMatch[1]);
                const type = timeMatch[2];
                this.consumerList[index][type] = state.val || '';
                await this.checkConsumers();
            }

            if (id === this.feedInDatapoint) {
                await this.checkConsumers();

                if (this.percentTimer) {
                    clearTimeout(this.percentTimer);
                }
                this.percentTimer = setTimeout(
                    async () => {
                        for (const v of this.consumerList.filter(v => v.ruletype === 'percent')) {
                            await this.controlPercentConsumer(v);
                        }
                        this.percentTimer = null;
                    },
                    (this.config.delaySecondsProzent || 60) * 1000,
                );

                if (this.batteryTimer) {
                    clearTimeout(this.batteryTimer);
                }
                this.batteryTimer = setTimeout(
                    async () => {
                        if (!this.feedInDatapoint) {
                            return;
                        }
                        const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);
                        let feedIn = Number(feedInState?.val) || 0;
                        if (this.config.feedinNegativ) {
                            feedIn = -feedIn;
                        }

                        for (const v of this.consumerList.filter(v => v.ruletype === 'battery')) {
                            await this.controlBattery(v, feedIn);
                        }
                        this.batteryTimer = null;
                    },
                    (this.config.batteryDelaySeconds || 60) * 1000,
                );
            }
        }
    }

    async checkConsumers() {
        if (this.checkRunning) {
            this.checkQueued = true;
            return;
        }
        this.checkRunning = true;
        this.checkQueued = false;

        try {
            if (!this.feedInDatapoint) {
                this.log.warn('‚ùó Kein FeedIn-Datenpunkt gesetzt ‚Äì checkConsumers() wird √ºbersprungen.');
                await this.sendNotification(
                    'smartloadmanager',
                    'alert',
                    '‚ùó Kein FeedIn-Datenpunkt gesetzt ‚Äì Regelung √ºbersprungen.',
                );
                this.checkRunning = false;
                if (this.checkQueued) {
                    await this.checkConsumers();
                }
                return;
            }

            const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);
            let feedIn = Number(feedInState?.val) || 0;
            if (this.config.feedinNegativ) {
                feedIn = -feedIn;
            }

            const baseload = this.config.baseload || 0;
            const gridUsage = feedIn <= baseload;

            this.log.debug(`üìä FeedIn: ${feedIn} W, Baseload: ${baseload} W, GridUsage: ${gridUsage}`);

            // ----------------------------------
            // Einschalten binary + heating
            // ----------------------------------
            const sortedOn = [...this.consumerList]
                .filter(v => v.ruletype === 'binary' || v.ruletype === 'heating')
                .sort((a, b) => (a.priority || 1) - (b.priority || 1));

            this.log.debug(`üîç Einschalt-Pr√ºfung f√ºr ${sortedOn.length} binary/heating-Verbraucher.`);

            for (const v of sortedOn) {
                const idx = this.consumerList.indexOf(v);
                const id = `${this.namespace}.consumer.${idx}_${v.name.replace(/\s+/g, '_')}`;
                const mode = await this.getStateAsync(`${id}.controlMode`);

                this.log.debug(`‚û°Ô∏è Pr√ºfe "${v.name}" (Prio ${v.priority}, ${v.performance} W, Typ=${v.ruletype})`);

                if (!mode || mode.val !== 2) {
                    this.log.debug(`‚è≠Ô∏è Manueller Modus aktiv, √úberspringe.`);
                    continue;
                }

                const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime, v.name);

                let isOn = false;
                if (v.datapoint) {
                    const dpState = await this.getForeignStateAsync(v.datapoint);
                    if (dpState?.val === true) {
                        isOn = true;
                    }
                }
                if (v.numericDatapoint) {
                    const numState = await this.getForeignStateAsync(v.numericDatapoint);
                    const numVal = Number(numState?.val) || 0;
                    if (numVal === 1) {
                        isOn = true;
                    }
                    this.log.debug(`üî¢ NumericDatapoint f√ºr "${v.name}": ${v.numericDatapoint} = ${numVal}`);
                }

                this.log.debug(`üí° "${v.name}" Status: isOn=${isOn}`);

                // --- Zusatz-Checks f√ºr heating ---
                if (v.ruletype === 'heating' && withinWindow && !isOn) {
                    // Temperatur-Check
                    const tempState = v.temperatureDatapoint
                        ? await this.getForeignStateAsync(v.temperatureDatapoint)
                        : null;
                    const currentTemp = tempState?.val !== undefined ? Number(tempState.val) : null;

                    if (currentTemp !== null && v.maxTemperature !== undefined && currentTemp >= v.maxTemperature) {
                        this.log.warn(
                            `üî• "${v.name}" NICHT eingeschaltet ‚Äì Temperatur ${currentTemp}¬∞C >= MaxTemp ${v.maxTemperature}¬∞C`,
                        );
                        continue;
                    }
                    if (currentTemp !== null && v.minTemperature !== undefined && currentTemp < v.minTemperature) {
                        this.log.debug(
                            `üå°Ô∏è "${v.name}" noch nicht einschalten ‚Äì Temperatur ${currentTemp}¬∞C < MinTemp ${v.minTemperature}¬∞C`,
                        );
                        continue;
                    }

                    // Hardware-Freigabe
                    if (v.enableDatapoint) {
                        const enableState = await this.getForeignStateAsync(v.enableDatapoint);
                        if (!enableState?.val) {
                            this.log.warn(`üîí "${v.name}" NICHT eingeschaltet ‚Äì Hardwarefreigabe fehlt.`);
                            continue;
                        }
                    }

                    // Heartbeat
                    if (v.heartbeatDatapoint) {
                        const hbState = await this.getForeignStateAsync(v.heartbeatDatapoint);
                        if (!hbState?.val) {
                            this.log.warn(`üíî "${v.name}" NICHT eingeschaltet ‚Äì Heartbeat fehlt.`);
                            continue;
                        }
                    }
                }

                if (withinWindow) {
                    if (!gridUsage && v.performance <= feedIn - baseload && !isOn) {
                        this.log.debug(
                            `‚úÖ Einschalten m√∂glich: √úberschuss ${feedIn - baseload} W, innerhalb Zeitfenster (onDelay ${v.switchOnDelay || 0}s).`,
                        );
                        await this.switchConsumerWithDelay(v, true, v.switchOnDelay || 0);

                        feedIn -= v.performance;
                        this.log.debug(`üîÑ Verbleibender √úberschuss nach Zuschaltung: ${feedIn - baseload} W`);
                    } else if (gridUsage && !isOn) {
                        this.log.debug(`üö´ Nicht eingeschaltet: Netzbezug aktiv.`);
                    } else if (!isOn) {
                        this.log.debug(
                            `‚ö†Ô∏è Nicht eingeschaltet: √úberschuss zu gering (${feedIn - baseload} W < ${v.performance} W).`,
                        );
                    } else {
                        this.log.debug(`‚ÑπÔ∏è "${v.name}" ist bereits eingeschaltet ‚Äì keine Aktion n√∂tig.`);
                    }
                }
            }

            // ----------------------------------
            // Ausschalten binary + heating
            // ----------------------------------
            const sortedOff = [...this.consumerList]
                .filter(v => v.ruletype === 'binary' || v.ruletype === 'heating')
                .sort((a, b) => (b.priority || 1) - (a.priority || 1));

            this.log.debug(`üîç Ausschalt-Pr√ºfung f√ºr ${sortedOff.length} binary/heating-Verbraucher.`);

            for (const v of sortedOff) {
                const idx = this.consumerList.indexOf(v);
                const id = `${this.namespace}.consumer.${idx}_${v.name.replace(/\s+/g, '_')}`;
                const mode = await this.getStateAsync(`${id}.controlMode`);
                if (!mode || mode.val !== 2) {
                    continue;
                }

                const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime, v.name);

                let isOn = false;
                if (v.datapoint) {
                    const dpState = await this.getForeignStateAsync(v.datapoint);
                    if (dpState?.val === true) {
                        isOn = true;
                    }
                }
                if (v.numericDatapoint) {
                    const numState = await this.getForeignStateAsync(v.numericDatapoint);
                    const numVal = Number(numState?.val) || 0;
                    if (numVal === 1) {
                        isOn = true;
                    }
                }

                // --- Heizstab sofort abschalten bei fehlender Freigabe/Heartbeat ---
                if (v.ruletype === 'heating' && isOn) {
                    if (v.enableDatapoint) {
                        const enableState = await this.getForeignStateAsync(v.enableDatapoint);
                        if (!enableState?.val) {
                            this.log.warn(`üîí "${v.name}" wird abgeschaltet ‚Äì Hardwarefreigabe fehlt.`);
                            await this.switchConsumerWithDelay(v, false, 0);
                            continue;
                        }
                    }
                    if (v.heartbeatDatapoint) {
                        const hbState = await this.getForeignStateAsync(v.heartbeatDatapoint);
                        if (!hbState?.val) {
                            this.log.warn(`üíî "${v.name}" wird abgeschaltet ‚Äì Heartbeat fehlt.`);
                            await this.switchConsumerWithDelay(v, false, 0);
                            continue;
                        }
                    }
                }

                if (!isOn) {
                    continue;
                }

                if (v.alwaysOffAtTime && !withinWindow) {
                    this.log.debug(
                        `‚è≥ AlwaysOff aktiv: "${v.name}" - Zeitfenster vorbei, offDelay ${v.switchOffDelay || 0}s.`,
                    );
                    await this.switchConsumerWithDelay(v, false, v.switchOffDelay || 0);
                } else if (!v.alwaysOffAtTime && (!withinWindow || gridUsage)) {
                    this.log.debug(`‚è≥ Ausschalten: "${v.name}" - offDelay ${v.switchOffDelay || 0}s.`);
                    await this.switchConsumerWithDelay(v, false, v.switchOffDelay || 0);
                }
            }

            // --- Batterie bleibt unver√§ndert ---
            const batteryConsumers = this.consumerList.filter(c => c.ruletype === 'battery');
            for (const v of batteryConsumers) {
                await this.controlBattery(v, feedIn);
            }

            // Timer-√úbersicht
            const runningTimers = this.consumerList
                .filter(c => c.timer && c.timerEnd)
                .map(c => {
                    const remaining = Math.max(0, Math.round((c.timerEnd - Date.now()) / 1000));
                    return `${c.name}: noch ${remaining}s`;
                });

            if (runningTimers.length > 0) {
                this.log.debug(`üìã Aktive Timer ‚Üí ${runningTimers.join(' | ')}`);
            } else {
                this.log.debug('üìã Keine aktiven Timer.');
            }
        } catch (err) {
            this.log.error(`Error in checkConsumers: ${err.message}`);
            await this.sendNotification('smartloadmanager', 'alert', `‚ùå Fehler in checkConsumers: ${err.message}`);
        }

        this.checkRunning = false;
        if (this.checkQueued) {
            await this.checkConsumers();
        }
    }

    async controlPercentConsumer(v) {
        try {
            const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime);
            if (!withinWindow) {
                this.log.debug(`[Percent] ${v.name} au√üerhalb Zeitfenster ‚Äì auf 0% setzen`);
                await this.setForeignStateAsync(v.datapoint, 0);
                return;
            }

            if (!this.feedInDatapoint) {
                this.log.error('‚ùå feedInDatapoint ist nicht gesetzt!');
                await this.sendNotification('smartloadmanager', 'alert', '‚ùå feedInDatapoint ist nicht gesetzt!');
                return;
            }
            const feedInState = await this.getForeignStateAsync(this.feedInDatapoint);

            const feedInValue = Number(feedInState?.val) || 0;

            let surplus = this.config.feedinNegativ
                ? feedInValue < 0
                    ? -feedInValue
                    : 0
                : feedInValue > 0
                  ? feedInValue
                  : 0;

            surplus -= this.config.baseload || 0;
            if (surplus < 0) {
                surplus = 0;
            }

            const maxPerformance = v.maxPerformance || v.performance || 1000;
            let newPercent = Math.round((surplus / maxPerformance) * 100);
            newPercent = Math.min(100, Math.max(newPercent, v.minPercentStart || 0));

            const state = await this.getForeignStateAsync(v.datapoint);
            const currentPercent = Number(state?.val) || 0;

            if (newPercent !== currentPercent) {
                await this.setForeignStateAsync(v.datapoint, newPercent);
                this.log.info(`üîÅ ${v.name} wurde auf ${newPercent}% geregelt`);

                if (this.config.notifyPercent) {
                    await this.sendNotification(
                        'smartloadmanager',
                        'notify',
                        `‚öôÔ∏è ${v.name} wurde auf ${newPercent}% geregelt`,
                    );
                }
            } else {
                this.log.debug(`[Percent] ${v.name} bleibt bei ${currentPercent}%`);
            }
        } catch (error) {
            this.log.error(`‚ùå Fehler in controlPercentConsumer: ${error.message}`);
            await this.sendNotification(
                'smartloadmanager',
                'alert',
                `‚ùå Fehler in controlPercentConsumer: ${error.message}`,
            );
        }
    }

    async controlBattery(v, feedIn) {
        try {
            this.log.debug(`[Battery] Pr√ºfung f√ºr ${v.name}`);

            const withinWindow = this.timeWithinWindow(v.switchOnTime, v.switchOffTime);
            if (!withinWindow) {
                this.log.debug(`[Battery] ${v.name} au√üerhalb Zeitfenster ‚Äì auf 0`);
                if (v.batterySetpoint) {
                    await this.setForeignStateAsync(v.batterySetpoint, { val: 0, ack: true });
                }
                if (v.batteryControlModeDatapoint) {
                    await this.setForeignStateAsync(v.batteryControlModeDatapoint, { val: 0, ack: true });
                }
                return;
            }

            if (!v.batterySetpoint) {
                this.log.warn(`[Battery] ${v.name} hat keinen batterySetpoint`);
                if (v.batteryControlModeDatapoint) {
                    await this.setForeignStateAsync(v.batteryControlModeDatapoint, { val: 0, ack: true });
                }
                return;
            }

            let soc = null;
            let targetSoc = null;
            if (v.batterySOC && v.batteryTargetSOC) {
                const socState = await this.getForeignStateAsync(v.batterySOC);
                const targetSocState = await this.getForeignStateAsync(v.batteryTargetSOC);
                soc = Number(socState?.val);
                targetSoc = Number(targetSocState?.val);
                if (isNaN(soc) || isNaN(targetSoc)) {
                    this.log.warn(`[Battery] ${v.name}: Ung√ºltiger SOC oder targetSOC`);
                    soc = null;
                    targetSoc = null;
                }
            }

            const surplus = (this.config.feedinNegativ ? -feedIn : feedIn) - (this.config.baseload || 0);
            let powerToSet = 0;
            let modeToSet = 0;

            if (surplus <= 0) {
                powerToSet = 0;
                modeToSet = 0;
            } else if (soc !== null && targetSoc !== null && soc >= targetSoc) {
                powerToSet = 0;
                modeToSet = 1;
            } else {
                powerToSet = Math.min(surplus, v.performance || 1000);
                modeToSet = 2;
            }

            const oldPower = Number((await this.getForeignStateAsync(v.batterySetpoint))?.val) || 0;
            const oldMode = this.batteryControlModeDatapoint
                ? Number((await this.getForeignStateAsync(this.batteryControlModeDatapoint))?.val) || 0
                : -1;

            if (powerToSet !== oldPower) {
                await this.setForeignStateAsync(v.batterySetpoint, { val: powerToSet, ack: true });
                this.log.info(`üîÅ Batterie ${v.name}: Ladeleistung auf ${powerToSet}W gesetzt`);
                if (this.config.notifyBattery) {
                    await this.sendNotification(
                        'smartloadmanager',
                        'notify',
                        `üîã Batterie ${v.name}: Ladeleistung auf ${powerToSet}W gesetzt`,
                    );
                }
            } else {
                this.log.debug(`[Battery] ${v.name} Ladeleistung bleibt bei ${oldPower}W`);
            }

            if (this.batteryControlModeDatapoint && modeToSet !== oldMode) {
                await this.setForeignStateAsync(this.batteryControlModeDatapoint, { val: modeToSet, ack: true });
                this.log.debug(`[Battery] ${v.name} Modus ge√§ndert: ${oldMode} ‚Üí ${modeToSet}`);
                if (this.config.notifyBattery) {
                    await this.sendNotification(
                        'smartloadmanager',
                        'notify',
                        `üîã Batterie ${v.name}: Modus ge√§ndert auf ${modeToSet}`,
                    );
                }
            }
        } catch (error) {
            this.log.error(`[Battery] Fehler f√ºr ${v.name}: ${error.message}`);
            await this.sendNotification(
                'smartloadmanager',
                'alert',
                `‚ùå Batterie-Fehler f√ºr ${v.name}: ${error.message}`,
            );
        }
    }

    /**
     * Zentrale Schaltfunktion: setzt sowohl booleanen Schalter-DP als auch optionalen numerischen DP (0/1)
     *
     * @param consumer - Der Verbraucher, der geschaltet werden soll
     * @param turnOn - true zum Einschalten, false zum Ausschalten
     */
    async doSwitchConsumer(consumer, turnOn) {
        const targetState = !!turnOn;

        // Prim√§rer boolean-DP
        if (consumer.datapoint) {
            await this.setForeignStateAsync(consumer.datapoint, { val: targetState, ack: true });
        }

        // Optionaler numerischer DP
        if (consumer.numericDatapoint) {
            await this.setForeignStateAsync(consumer.numericDatapoint, { val: targetState ? 1 : 0, ack: true });
            this.log.debug(`üî¢ NumericDatapoint f√ºr "${consumer.name}" gesetzt auf ${targetState ? 1 : 0}`);
        }
    }

    async switchConsumerWithDelay(consumer, turnOn, delaySeconds) {
        const delay =
            delaySeconds !== undefined
                ? delaySeconds
                : turnOn
                  ? consumer.switchOnDelay || 0
                  : consumer.switchOffDelay || 0;

        const doSwitch = async () => {
            if (consumer.ruletype === 'heating' && turnOn) {
                const tempState = consumer.temperatureDatapoint
                    ? await this.getForeignStateAsync(consumer.temperatureDatapoint)
                    : null;
                const currentTemp = tempState?.val !== undefined ? Number(tempState.val) : null;

                if (
                    currentTemp !== null &&
                    consumer.maxTemperature !== undefined &&
                    currentTemp >= consumer.maxTemperature
                ) {
                    consumer.timer = null;
                    consumer.timerEnd = null;
                    consumer.pendingAction = null;
                    return;
                }

                if (
                    consumer.minTemperature !== undefined &&
                    currentTemp !== null &&
                    currentTemp < consumer.minTemperature
                ) {
                    consumer.timer = null;
                    consumer.timerEnd = null;
                    consumer.pendingAction = null;
                    return;
                }

                if (consumer.enableDatapoint) {
                    const enableState = await this.getForeignStateAsync(consumer.enableDatapoint);
                    if (!enableState?.val) {
                        consumer.timer = null;
                        consumer.timerEnd = null;
                        consumer.pendingAction = null;
                        return;
                    }
                }

                if (consumer.heartbeatDatapoint) {
                    const hbState = await this.getForeignStateAsync(consumer.heartbeatDatapoint);
                    if (!hbState?.val) {
                        consumer.timer = null;
                        consumer.timerEnd = null;
                        consumer.pendingAction = null;
                        return;
                    }
                }
            }

            await this.doSwitchConsumer(consumer, turnOn);
            consumer.timer = null;
            consumer.timerEnd = null;
            consumer.pendingAction = null;
        };

        if (consumer.timer) {
            if (consumer.pendingAction === turnOn) {
                return;
            }
            clearTimeout(consumer.timer);
            consumer.timer = null;
            consumer.timerEnd = null;
            consumer.pendingAction = null;
        }

        if (delay > 0) {
            consumer.timerEnd = Date.now() + delay * 1000;
            consumer.pendingAction = turnOn;
            consumer.timer = setTimeout(doSwitch, delay * 1000);
        } else {
            await doSwitch();
        }
    }

    // Zentrale, einheitliche Notification-Funktion
    // Aufruf: await this.sendNotification('smartloadmanager', 'info'|'notify'|'alert', 'Nachricht');
    async sendNotification(scope, category, message) {
        try {
            // 1) Controller-Notification
            await this.registerNotification(scope, category, message);
            this.log.debug(`üì® Controller-Notification [${scope}/${category}]: ${message}`);

            // 2) Messenger-Nachrichten
            const cfg = this.config;

            // Telegram
            if (cfg.telegramInstance) {
                this.sendTo(cfg.telegramInstance, message);
                this.log.debug(`üì® Telegram ‚Üí ${cfg.telegramInstance}: ${message}`);
            }

            // Gotify
            if (cfg.gotifyInstance) {
                this.sendTo(cfg.gotifyInstance, {
                    title: 'SmartLoadManager',
                    message: message,
                });
                this.log.debug(`üì® Gotify ‚Üí ${cfg.gotifyInstance}: ${message}`);
            }

            // E-Mail
            if (cfg.emailInstance) {
                this.sendTo(cfg.emailInstance, {
                    text: message,
                    subject: 'SmartLoadManager',
                });
                this.log.debug(`üì® Email ‚Üí ${cfg.emailInstance}: ${message}`);
            }

            // WhatsApp-cmd
            if (cfg.whatsappInstance) {
                this.sendTo(cfg.whatsappInstance, { text: message });
                this.log.debug(`üì® WhatsApp ‚Üí ${cfg.whatsappInstance}: ${message}`);
            }

            // Signal-cmd
            if (cfg.signalInstance) {
                this.sendTo(cfg.signalInstance, { text: message });
                this.log.debug(`üì® Signal ‚Üí ${cfg.signalInstance}: ${message}`);
            }

            // Pushover
            if (cfg.pushoverInstance) {
                this.sendTo(cfg.pushoverInstance, {
                    message: message,
                    title: 'SmartLoadManager',
                });
                this.log.debug(`üì® Pushover ‚Üí ${cfg.pushoverInstance}: ${message}`);
            }
        } catch (e) {
            this.log.warn(`‚ùó Fehler beim Senden der Notification: ${e.message}`);
        }
    }

    async initializeConsumerStatus() {
        // Initiale Status-Updates
        for (const v of this.consumerList) {
            const channelId = `consumer.${this.consumerList.indexOf(v)}_${v.name.replace(/\s+/g, '_')}`;
            const modeState = await this.getStateAsync(`${this.namespace}.${channelId}.controlMode`);
            if (!modeState) {
                await this.setStateAsync(`${this.namespace}.${channelId}.controlMode`, {
                    val: 2,
                    ack: true,
                });
            }
        }
    }

    /*
    // Testfunktion
    async testBatteryControlModeWrite() {
        this.log.info(`Teste Schreibzugriff auf batteryControlModeDatapoint: ${this.batteryControlModeDatapoint}`);

        if (!this.batteryControlModeDatapoint) {
            this.log.error("batteryControlModeDatapoint nicht konfiguriert");
            return;
        }

        const obj = await this.getForeignObjectAsync(this.batteryControlModeDatapoint);
        if (!obj) {
            this.log.error(`batteryControlModeDatapoint ${this.batteryControlModeDatapoint} existiert nicht!`);
            return;
        }

        if (!obj.common?.write) {
            this.log.warn(`batteryControlModeDatapoint ist nicht schreibbar!`);
            return;
        }

        const valBefore = await this.getForeignStateAsync(this.batteryControlModeDatapoint);
        this.log.info(`Vor Schreibversuch aktueller Wert: ${valBefore?.val}`);

        try {
            await this.setForeignStateAsync(this.batteryControlModeDatapoint, { val: 1, ack: true });
            this.log.info(`Schreibversuch durchgef√ºhrt`);

            const valAfter = await this.getForeignStateAsync(this.batteryControlModeDatapoint);
            this.log.info(`Nach Schreibversuch aktueller Wert: ${valAfter?.val}`);
        } catch (e) {
            this.log.error(`Fehler beim Schreiben: ${e.message}`);
        }
    }
    */

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    parseTimeToMinutes(timeStr) {
        if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
            return 0;
        }
        const [h, m] = timeStr.split(':').map(Number);
        if (isNaN(h) || isNaN(m)) {
            return 0;
        }
        return h * 60 + m;
    }

    async onUnload(callback) {
        try {
            if (this.percentTimer) {
                clearTimeout(this.percentTimer);
            }
            if (this.batteryTimer) {
                clearTimeout(this.batteryTimer);
            }
            for (const v of this.consumerList) {
                if (v.timer) {
                    clearTimeout(v.timer);
                    v.timer = null;
                }
            }
            callback();
        } catch {
            callback();
        }
    }
}

if (require.main !== module) {
    module.exports = options => new ZeroFeedIn(options);
} else {
    new ZeroFeedIn();
}
